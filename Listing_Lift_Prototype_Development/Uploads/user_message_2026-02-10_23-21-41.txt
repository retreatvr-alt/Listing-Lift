Here is the complete, merged prompt to copy-paste into DeepAgent:

---

## Image Enhancement Fix ‚Äî Complete Instructions

### Problem Summary

The "Run Enhancement" button loads but never completes. Server logs show the connection to the Abacus AI API is being terminated immediately (929 bytes received, then socket closed). There are three root causes:

1. **`stream: true` is used with image generation** ‚Äî image generation does not support streaming on the Abacus AI RouteLLM API. The server rejects the connection.
2. **Response parsing looks in the wrong place** ‚Äî code looks for `parsed.choices[0].delta.images` / `parsed.choices[0].message.images`, but images are returned in `message.content` as an array of objects with `type: "image_url"`.
3. **Model `gpt-5.1` may not support image editing** (input image ‚Üí enhanced output). `gpt-image-1` is the dedicated image editing model.
4. **Minor:** `ROOM_PROMPTS` is missing fallback keys for parent categories (`"Living Spaces"`, `"Exterior"`) so photos without a subcategory fall through to the Kitchen prompt.

---

### Change 1: Replace the entire enhance API route

**File:** `/app/api/photos/[id]/enhance/route.ts`

**Action:** Replace the entire file contents with:

```typescript
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth-options";
import { ROOM_PROMPTS, INTENSITY_MODIFIERS } from "@/lib/enhancement-prompts";
import { getFileUrl } from "@/lib/s3";

export const dynamic = "force-dynamic";
export const maxDuration = 120; // Allow up to 2 minutes for image generation

export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    const data = await request.json();
    const {
      intensity = "Moderate",
      skyReplacement = false,
      bedFixing = false,
      windowRecovery = false,
      brightness = false,
      perspective = false,
      reflection = false,
      additionalNotes = "",
      customPrompt = ""
    } = data;

    // Get photo with original URL
    const photo = await prisma.photo.findUnique({
      where: { id: params.id },
      include: {
        enhancementVersions: {
          orderBy: { versionNumber: 'desc' },
          take: 1
        }
      }
    });

    if (!photo) {
      return NextResponse.json({ error: "Photo not found" }, { status: 404 });
    }

    // Get accessible URL for the original photo
    const originalUrl = await getFileUrl(photo.originalUrl, true);

    // Build the prompt - use custom prompt if provided, otherwise build from settings
    let prompt: string;
    if (customPrompt && customPrompt.trim()) {
      prompt = customPrompt.trim();
    } else {
      const roomKey = photo.subCategory || photo.roomCategory;
      prompt = ROOM_PROMPTS[roomKey] || ROOM_PROMPTS[photo.roomCategory] || ROOM_PROMPTS["Kitchen"];
      prompt += INTENSITY_MODIFIERS[intensity] || INTENSITY_MODIFIERS["Moderate"];
    }

    // Add enhancement toggles
    const toggles: string[] = [];
    if (skyReplacement) toggles.push("Apply sky replacement with pleasant blue sky");
    if (bedFixing) toggles.push("Smooth and fix bed linens to appear crisp and inviting");
    if (windowRecovery) toggles.push("Recover and reveal exterior view through windows");
    if (brightness) toggles.push("Increase overall brightness and reduce shadows");
    if (perspective) toggles.push("Correct perspective and straighten vertical lines");
    if (reflection) toggles.push("Remove photographer reflections from mirrors and glass");

    if (toggles.length > 0) {
      prompt += `\n\nADDITIONAL ENHANCEMENT INSTRUCTIONS:\n${toggles.join('\n')}`;
    }

    if (additionalNotes) {
      prompt += `\n\nADMIN NOTES:\n${additionalNotes}`;
    }

    console.log('[ENHANCE] Starting enhancement for photo:', params.id);
    console.log('[ENHANCE] Using model: gpt-image-1');
    console.log('[ENHANCE] Original URL:', originalUrl?.substring(0, 100) + '...');
    console.log('[ENHANCE] Prompt length:', prompt.length);

    // Call the Abacus AI RouteLLM API ‚Äî NON-STREAMING for image generation
    const response = await fetch('https://apps.abacus.ai/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.ABACUSAI_API_KEY}`
      },
      body: JSON.stringify({
        model: 'gpt-image-1',
        messages: [
          {
            role: 'user',
            content: [
              {
                type: 'image_url',
                image_url: { url: originalUrl }
              },
              {
                type: 'text',
                text: prompt
              }
            ]
          }
        ],
        modalities: ['image'],
        image_config: {
          num_images: 1,
          aspect_ratio: photo.orientation === 'portrait' ? '3:4' : '4:3',
          quality: 'high'
        },
        max_tokens: 1000
        // NOTE: No stream: true ‚Äî image generation does not support streaming
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('[ENHANCE] API error:', response.status, errorText);
      return NextResponse.json({
        error: "Enhancement API failed",
        details: errorText,
        status: response.status
      }, { status: 500 });
    }

    const result = await response.json();
    console.log('[ENHANCE] API response keys:', Object.keys(result));
    console.log('[ENHANCE] Full response:', JSON.stringify(result).substring(0, 500));

    // Extract image URL from response ‚Äî check multiple possible locations
    let enhancedImageUrl = '';

    // Location 1: message.content array with type "image_url"
    const content = result.choices?.[0]?.message?.content;
    if (Array.isArray(content)) {
      for (const item of content) {
        if (item?.type === 'image_url' && item?.image_url?.url) {
          enhancedImageUrl = item.image_url.url;
          break;
        }
      }
    }

    // Location 2: message.images array (fallback)
    if (!enhancedImageUrl) {
      const images = result.choices?.[0]?.message?.images;
      if (images && images.length > 0) {
        enhancedImageUrl = images[0]?.image_url?.url || images[0]?.url || '';
      }
    }

    // Location 3: direct URL in content string (some models return this)
    if (!enhancedImageUrl && typeof content === 'string' && content.startsWith('http')) {
      enhancedImageUrl = content;
    }

    console.log('[ENHANCE] Extracted image URL:', enhancedImageUrl ? enhancedImageUrl.substring(0, 100) + '...' : 'NONE');

    if (!enhancedImageUrl) {
      console.error('[ENHANCE] No image URL found in response:', JSON.stringify(result).substring(0, 1000));
      return NextResponse.json({
        error: "No enhanced image returned from API",
        debug: JSON.stringify(result).substring(0, 500)
      }, { status: 500 });
    }

    // Save to database
    const versionNumber = (photo?.enhancementVersions?.[0]?.versionNumber || 0) + 1;

    await prisma.enhancementVersion.create({
      data: {
        photoId: params.id,
        versionNumber,
        enhancedUrl: enhancedImageUrl,
        intensity,
        skyReplacement,
        bedFixing,
        windowRecovery,
        brightness,
        perspective,
        reflection,
        additionalNotes: additionalNotes || null
      }
    });

    await prisma.photo.update({
      where: { id: params.id },
      data: {
        enhancedUrl: enhancedImageUrl,
        status: 'Enhanced'
      }
    });

    console.log('[ENHANCE] Success! Version:', versionNumber);

    return NextResponse.json({
      status: 'completed',
      enhancedUrl: enhancedImageUrl,
      versionNumber
    });

  } catch (error) {
    console.error('[ENHANCE] Enhancement error:', error);
    return NextResponse.json({
      error: "Enhancement failed",
      details: error instanceof Error ? error.message : String(error)
    }, { status: 500 });
  }
}
```

**Why these changes:**
- Removed `stream: true` ‚Äî image generation does not support streaming, this was causing the socket termination
- Changed model from `gpt-5.1` to `gpt-image-1` ‚Äî dedicated image editing model
- Added `quality: 'high'` to image_config
- Fixed response parsing ‚Äî checks `message.content` array for `type: "image_url"` items (the correct Abacus AI format), with fallbacks for `.images` and direct string URL
- Returns simple JSON instead of SSE stream ‚Äî simpler, more reliable
- Added comprehensive `[ENHANCE]` logging at every step for production debugging
- Added `customPrompt` parameter support for the editable prompts feature
- Added `maxDuration = 120` ‚Äî image generation can take 30-60 seconds
- Proper error responses with details surfaced to the client

**IMPORTANT:** If `gpt-image-1` does not work, try these model names in order: `gpt-image-1.5`, `flux-kontext`, `dall-e`. The `[ENHANCE]` logging will show the exact API error so you can iterate. Check the server logs after the first test.

---

### Change 2: Update the client-side `handleEnhance` function

**File:** `/app/admin/submissions/[id]/page.tsx`

**Action:** Find the existing `handleEnhance` function and replace it entirely with:

```typescript
const handleEnhance = async () => {
  if (!selectedPhoto) return;
  setEnhancing(true);

  try {
    const response = await fetch(`/api/photos/${selectedPhoto.id}/enhance`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(enhanceSettings)
    });

    const result = await response.json();

    if (!response.ok) {
      console.error('Enhancement failed:', result);
      alert(`Enhancement failed: ${result.error || 'Unknown error'}${result.details ? '\n\nDetails: ' + result.details : ''}`);
      return;
    }

    if (result.status === 'completed' && result.enhancedUrl) {
      await fetchSubmission();
      alert('Enhancement complete!');
    } else {
      console.error('Unexpected response:', result);
      alert('Enhancement returned unexpected response. Check console for details.');
    }
  } catch (error) {
    console.error('Enhancement failed:', error);
    alert('Enhancement failed. Please try again.');
  } finally {
    setEnhancing(false);
  }
};
```

**Why:** The old handler used SSE stream parsing (`getReader`, `TextDecoder`, parsing `data:` lines). Since the API route now returns simple JSON, the client handler needs to match. This also surfaces actual error messages to the user instead of silently failing.

---

### Change 3: Add `customPrompt` to enhanceSettings state and add editable prompt UI

**File:** `/app/admin/submissions/[id]/page.tsx`

**Action (Part A):** Find the `enhanceSettings` state declaration and add `customPrompt`:

```typescript
const [enhanceSettings, setEnhanceSettings] = useState({
  intensity: 'Moderate',
  skyReplacement: false,
  bedFixing: false,
  windowRecovery: false,
  brightness: false,
  perspective: false,
  reflection: false,
  additionalNotes: '',
  customPrompt: ''
});
```

**Action (Part B):** In the Enhancement Settings section of the JSX, add this block **after** the "Additional Notes" textarea and **before** the "Enhance" button:

```tsx
{/* Editable Enhancement Prompt */}
<div>
  <div className="flex items-center justify-between mb-1">
    <label className="text-sm font-medium text-gray-700">Enhancement Prompt</label>
    <button
      type="button"
      onClick={() => {
        if (enhanceSettings.customPrompt) {
          setEnhanceSettings(prev => ({ ...prev, customPrompt: '' }));
        } else {
          setEnhanceSettings(prev => ({
            ...prev,
            customPrompt: 'Enhance this real estate photo. Improve lighting, colors, and make the space look inviting and professional. Maintain photorealism - do not make it look artificial or over-processed.'
          }));
        }
      }}
      className="text-xs text-blue-600 hover:text-blue-800"
    >
      {enhanceSettings.customPrompt ? 'Use default prompt' : 'Edit prompt'}
    </button>
  </div>
  {!enhanceSettings.customPrompt && (
    <p className="text-xs text-gray-500">Using default room-specific prompt with selected intensity. Click "Edit prompt" to customize.</p>
  )}
  {enhanceSettings.customPrompt && (
    <textarea
      value={enhanceSettings.customPrompt}
      onChange={(e) => setEnhanceSettings(prev => ({ ...prev, customPrompt: e.target.value }))}
      className="w-full border border-gray-200 rounded-lg px-3 py-2 text-sm font-mono"
      rows={6}
      placeholder="Enter custom enhancement prompt..."
    />
  )}
</div>
```

**Why:** This gives the admin the ability to click "Edit prompt" to see and modify the enhancement prompt before running enhancement. When `customPrompt` is empty (default), the server uses the built-in room-specific prompts from `enhancement-prompts.ts`. When set, it overrides them. Clicking "Use default prompt" clears it back.

---

### Change 4: Add missing parent-category fallback keys to ROOM_PROMPTS

**File:** `/lib/enhancement-prompts.ts`

**Action:** At the end of the `ROOM_PROMPTS` object (just before the closing `};`), add these three entries. These are fallbacks so photos assigned to a parent category without a subcategory don't silently fall through to the Kitchen prompt:

After the `Miscellaneous` entry, add:

```typescript
  // Fallbacks for parent categories (used when no subcategory is set)
  "Living Spaces": `LIVING ROOM ENHANCEMENT PROMPT
====
Enhance this living room photo for a vacation rental listing to maximize perceived spaciousness and create an inviting, comfortable atmosphere.

‚ö†Ô∏è CRITICAL ACCURACY REQUIREMENTS ‚ö†Ô∏è
* DO NOT add any windows, doors, or architectural elements that are not visible in the original photo
* DO NOT change, replace, or alter any furniture - only enhance the existing furniture's appearance
* DO NOT add any objects, decorations, or features that are not present in the original image
* PRESERVE the exact layout, furniture placement, and architectural features of the original photo

CORRECTIONS:
* Straighten all vertical lines (walls, door frames, windows, furniture edges)
* Correct wide-angle edge distortion
* Fix any perspective tilt from camera angle
* Remove photographer reflection from any glass, mirrors, or TV screens

SPACIOUSNESS:
* Brighten to emphasize openness and volume
* Enhance natural light from windows
* Recover exterior views through any blown-out windows
* Create sense of depth and flow

LIGHTING:
* Balance bright windows with interior exposure (HDR effect)
* Reveal details in shadow areas without losing contrast
* Natural, welcoming illumination throughout

COLOR & ATMOSPHERE:
* Warm, inviting color temperature
* Accurate furniture and decor colors
* Subtle vibrancy enhancement without oversaturation

OUTPUT QUALITY: Spacious, inviting living space with "visual comfort".`,

  "Exterior": `BUILDING EXTERIOR ENHANCEMENT PROMPT
====
Enhance this building exterior photo for a vacation rental listing to create a compelling, "curiosity-generating" curb appeal image.

‚ö†Ô∏è CRITICAL ACCURACY REQUIREMENTS ‚ö†Ô∏è
* DO NOT add any windows, doors, or architectural elements that are not visible in the original photo
* DO NOT change the structure, style, or architectural details of the building
* DO NOT add any objects, landscaping, or features that are not present in the original image
* Sky replacement IS allowed as it does not misrepresent the property itself

SKY ENHANCEMENT (ALLOWED):
* If sky is overcast, cloudy, or gray: replace with pleasant blue sky
* Option: Convert to golden hour/sunset mood if appropriate
* Option: Create twilight look with warm interior lights visible

CORRECTIONS:
* Straighten any tilted framing
* Correct wide-angle distortion on edges
* Enhance structure to appear imposing

BUILDING & ARCHITECTURE:
* Enhance the appearance of existing siding, brick, stone, etc.
* Brighten and clean the appearance of windows and doors
* DO NOT change any architectural features or add/remove elements

LANDSCAPING (ENHANCEMENT ONLY):
* Enhance green grass vibrancy naturally (not neon)
* Brighten existing foliage colors appropriately for season
* DO NOT add landscaping features that don't exist

OUTPUT QUALITY: High-conversion "curiosity-generating" exterior.`
```

**Why:** When a photo has `roomCategory: "Living Spaces"` or `roomCategory: "Exterior"` but no `subCategory` set, the prompt lookup `ROOM_PROMPTS[photo.subCategory || photo.roomCategory]` would resolve to `ROOM_PROMPTS["Living Spaces"]` or `ROOM_PROMPTS["Exterior"]`, which didn't exist. It would fall through to `ROOM_PROMPTS["Kitchen"]` as the default, which is wrong. These entries fix that.

---

### Change 5 (Optional ‚Äî implement after manual enhancement is working): Auto-Enhancement on Submission

**File:** `/app/api/submissions/route.ts`

**Action:** At the end of the POST handler, just before the `return NextResponse.json({ success: true, ...` line, add:

```typescript
// Trigger auto-enhancement in background (fire-and-forget)
const baseUrl = process.env.NEXT_PUBLIC_APP_URL || process.env.VERCEL_URL || '';
if (baseUrl) {
  fetch(`${baseUrl}/api/submissions/${submission.id}/auto-enhance`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' }
  }).catch(err => console.error('Auto-enhance trigger failed:', err));
}
```

**Then create a new file:** `/app/api/submissions/[id]/auto-enhance/route.ts`

```typescript
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { ROOM_PROMPTS, INTENSITY_MODIFIERS } from "@/lib/enhancement-prompts";
import { getFileUrl } from "@/lib/s3";

export const dynamic = "force-dynamic";
export const maxDuration = 300; // 5 minutes for batch processing

export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const submission = await prisma.submission.findUnique({
      where: { id: params.id },
      include: { photos: true }
    });

    if (!submission) {
      return NextResponse.json({ error: "Submission not found" }, { status: 404 });
    }

    console.log(`[AUTO-ENHANCE] Starting auto-enhancement for submission ${submission.submissionNumber} (${submission.photos.length} photos)`);

    let successCount = 0;
    let failCount = 0;

    for (const photo of submission.photos) {
      try {
        const originalUrl = await getFileUrl(photo.originalUrl, true);
        const roomKey = photo.subCategory || photo.roomCategory;
        let prompt = ROOM_PROMPTS[roomKey] || ROOM_PROMPTS[photo.roomCategory] || ROOM_PROMPTS["Kitchen"];
        prompt += INTENSITY_MODIFIERS["Moderate"];

        console.log(`[AUTO-ENHANCE] Enhancing photo ${photo.id} (${roomKey})`);

        const response = await fetch('https://apps.abacus.ai/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${process.env.ABACUSAI_API_KEY}`
          },
          body: JSON.stringify({
            model: 'gpt-image-1',
            messages: [
              {
                role: 'user',
                content: [
                  { type: 'image_url', image_url: { url: originalUrl } },
                  { type: 'text', text: prompt }
                ]
              }
            ],
            modalities: ['image'],
            image_config: {
              num_images: 1,
              aspect_ratio: photo.orientation === 'portrait' ? '3:4' : '4:3',
              quality: 'high'
            },
            max_tokens: 1000
          })
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error(`[AUTO-ENHANCE] API error for photo ${photo.id}:`, errorText);
          failCount++;
          continue;
        }

        const result = await response.json();

        // Extract image URL ‚Äî same logic as manual enhance
        let enhancedImageUrl = '';
        const content = result.choices?.[0]?.message?.content;
        if (Array.isArray(content)) {
          for (const item of content) {
            if (item?.type === 'image_url' && item?.image_url?.url) {
              enhancedImageUrl = item.image_url.url;
              break;
            }
          }
        }
        if (!enhancedImageUrl) {
          const images = result.choices?.[0]?.message?.images;
          if (images && images.length > 0) {
            enhancedImageUrl = images[0]?.image_url?.url || images[0]?.url || '';
          }
        }
        if (!enhancedImageUrl && typeof content === 'string' && content.startsWith('http')) {
          enhancedImageUrl = content;
        }

        if (!enhancedImageUrl) {
          console.error(`[AUTO-ENHANCE] No image URL for photo ${photo.id}`);
          failCount++;
          continue;
        }

        // Save to database
        await prisma.enhancementVersion.create({
          data: {
            photoId: photo.id,
            versionNumber: 1,
            enhancedUrl: enhancedImageUrl,
            intensity: 'Moderate',
            skyReplacement: false,
            bedFixing: false,
            windowRecovery: false,
            brightness: false,
            perspective: false,
            reflection: false,
            additionalNotes: 'Auto-enhanced on submission'
          }
        });

        await prisma.photo.update({
          where: { id: photo.id },
          data: {
            enhancedUrl: enhancedImageUrl,
            status: 'Enhanced'
          }
        });

        successCount++;
        console.log(`[AUTO-ENHANCE] Photo ${photo.id} enhanced successfully`);

      } catch (err) {
        console.error(`[AUTO-ENHANCE] Error enhancing photo ${photo.id}:`, err);
        failCount++;
      }
    }

    // Update submission status
    await prisma.submission.update({
      where: { id: params.id },
      data: { status: 'In Progress' }
    });

    console.log(`[AUTO-ENHANCE] Complete. Success: ${successCount}, Failed: ${failCount}`);

    return NextResponse.json({
      success: true,
      enhanced: successCount,
      failed: failCount
    });

  } catch (error) {
    console.error('[AUTO-ENHANCE] Error:', error);
    return NextResponse.json({ error: "Auto-enhancement failed" }, { status: 500 });
  }
}
```

**Why:** This runs automatically after a submission is created. It loops through every photo, applies the default Moderate-intensity room-specific prompt, calls the image generation API, and saves the result. The fire-and-forget call in the submissions route means the user gets their confirmation page immediately while enhancement runs in the background. The admin dashboard will show "Enhanced" status as each photo completes.

**Note:** Implement this AFTER confirming manual enhancement works. Get Change 1 and 2 working first, test a manual enhancement, check the server logs for the `[ENHANCE]` output, then proceed with auto-enhancement.

---

### Summary of All Changes

| # | What | File | Priority |
|---|------|------|----------|
| 1 | Replace entire enhance route ‚Äî remove streaming, use `gpt-image-1`, fix response parsing, add logging | `/app/api/photos/[id]/enhance/route.ts` | üî¥ CRITICAL |
| 2 | Simplify `handleEnhance` ‚Äî use JSON response instead of SSE stream parsing | `/app/admin/submissions/[id]/page.tsx` | üî¥ CRITICAL |
| 3 | Add `customPrompt` to state + editable prompt textarea UI | `/app/admin/submissions/[id]/page.tsx` | üü° MEDIUM |
| 4 | Add `"Living Spaces"` and `"Exterior"` fallback keys to `ROOM_PROMPTS` | `/lib/enhancement-prompts.ts` | üü° MEDIUM |
| 5 | Auto-enhancement on submission (fire-and-forget background trigger + new route) | `/app/api/submissions/route.ts` + new `/app/api/submissions/[id]/auto-enhance/route.ts` | üü¢ DO AFTER 1-2 WORK |

**‚ö†Ô∏è IMPORTANT:** If `gpt-image-1` does not work on the Abacus platform, try these model names in order: `gpt-image-1.5`, `flux-kontext`, `dall-e`. The `[ENHANCE]` console logging will show the exact API error response so you can identify the correct model name quickly. Check server logs after the first test attempt.